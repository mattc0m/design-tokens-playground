/**
 * Style Dictionary module
 *
 * @module style-dictionary
 * @typicalname StyleDictionary
 * @example
 * ```js
 * import StyleDictionary from 'style-dictionary';
 * new StyleDictionary.extend('config.json').buildAllPlatforms();
 * ```
 */
export default class StyleDictionary extends Register {
    static VERSION: string;
    /**
     * @param {Config | string} config
     * @param {{
     *   init?: boolean,
     *   verbosity?: LogConfig['verbosity'],
     *   warnings?: LogConfig['warnings'],
     *   volume?: Volume
     * }} ctorOpts
     */
    constructor(config?: Config | string, { init, verbosity, warnings, volume }?: {
        init?: boolean;
        verbosity?: LogConfig["verbosity"];
        warnings?: LogConfig["warnings"];
        volume?: Volume;
    });
    /** @param {Config} v */
    set options(v: import("../types/Config.ts").Config);
    /** @returns {Config} */
    get options(): import("../types/Config.ts").Config;
    _options: import("../types/Config.ts").Config | undefined;
    config: string | import("../types/Config.ts").Config;
    /** @type {Tokens|TransformedTokens|PreprocessedTokens} */
    tokens: Tokens | TransformedTokens | PreprocessedTokens;
    /** @type {TransformedToken[]} */
    allTokens: TransformedToken[];
    /** @type {boolean | undefined} */
    usesDtcg: boolean | undefined;
    /** @type {LogConfig} */
    log: LogConfig;
    /** @type {string[]} */
    source: string[];
    /** @type {string[]} */
    include: string[];
    /** @type {ExpandConfig|undefined} */
    expand: ExpandConfig | undefined;
    /** @type {Record<string, PlatformConfig>} */
    platforms: Record<string, PlatformConfig>;
    /** @type {string[]} */
    parsers: string[];
    /** @type {string[]} */
    preprocessors: string[];
    /** @type {Volume} */
    volume: Volume;
    /**
     * Gets set after transform because filter happens on format level,
     * so we know they are transformed by then.
     * @type {TransformedTokens}
     */
    unfilteredTokens: TransformedTokens;
    /** @type {TransformedToken[]} */
    unfilteredAllTokens: TransformedToken[];
    hasInitialized: Promise<any>;
    hasInitializedResolve: (value: any) => void;
    /**
     * @param {{verbosity?: LogConfig['verbosity'], warnings?: LogConfig['warnings']}} [opts]
     * @returns
     */
    init(opts?: {
        verbosity?: LogConfig["verbosity"];
        warnings?: LogConfig["warnings"];
    } | undefined): Promise<StyleDictionary>;
    /**
     * @param {Config | string} [config]
     * @param {{
     *   mutateOriginal?: boolean,
     *   verbosity?: LogConfig['verbosity'],
     *   warnings?: LogConfig['warnings'],
     *   volume?: Volume
     * }} [opts]
     * @returns {Promise<StyleDictionary>}
     */
    extend(config?: string | import("../types/Config.ts").Config | undefined, opts?: {
        mutateOriginal?: boolean;
        verbosity?: LogConfig["verbosity"];
        warnings?: LogConfig["warnings"];
        volume?: Volume;
    } | undefined): Promise<StyleDictionary>;
    /**
     * @param {ExpandConfig} [expandCfg]
     * @returns
     */
    shouldRunExpansion(expandCfg?: import("../types/Config.ts").ExpandConfig | undefined): boolean;
    /**
     * @param {string} platform
     * @returns {Promise<TransformedTokens>}
     */
    exportPlatform(platform: string): Promise<TransformedTokens>;
    /**
     * This will get the dictionary / platformConfig for specified platform name
     * Runs transforms, reference resolutions
     * @param {string} platform
     * @returns
     */
    getPlatform(platform: string): Promise<{
        dictionary: {
            tokens: import("../types/DesignToken.ts").TransformedTokens;
            allTokens: import("../types/DesignToken.ts").TransformedToken[];
        };
        platformConfig: import("../types/Config.ts").PlatformConfig;
    }>;
    /**
     * Runs the format step and collects logs
     * This step may also return no output if all has been filtered out
     * Or return no destination if no destination was given,
     * this can happen if user wants to get the output in JS memory,
     * rather than outputted as a file on the filesystem
     *
     * @param {File} file
     * @param {PlatformConfig} platform
     * @param {Dictionary} dictionary
     * @returns {Promise<{
     *   logs: Record<"warning" | "success", string[]>
     *   destination?: string
     *   output?: unknown
     * }>}
     */
    formatFile(file: File, platform: PlatformConfig, dictionary: Dictionary): Promise<{
        logs: Record<"warning" | "success", string[]>;
        destination?: string;
        output?: unknown;
    }>;
    /**
     * @param {string} platform
     */
    formatPlatform(platform: string): Promise<{
        output: unknown;
        destination: string | undefined;
    }[]>;
    formatAllPlatforms(): Promise<{}>;
    /**
     * @param {string} platform
     * @returns
     */
    buildPlatform(platform: string): Promise<this>;
    buildAllPlatforms(): Promise<this>;
    /**
     * @param {string} platform
     * @returns
     */
    cleanPlatform(platform: string): Promise<this>;
    cleanAllPlatforms(): Promise<this>;
}
export type Volume = import("../types/Volume.ts").Volume;
export type Config = import("../types/Config.ts").Config;
export type PlatformConfig = import("../types/Config.ts").PlatformConfig;
export type LogConfig = import("../types/Config.ts").LogConfig;
export type Expand = import("../types/Config.ts").Expand;
export type ExpandConfig = import("../types/Config.ts").ExpandConfig;
export type File = import("../types/File.ts").File;
export type Filter = import("../types/Filter.ts").Filter;
export type Token = import("../types/DesignToken.ts").DesignToken;
export type TransformedToken = import("../types/DesignToken.ts").TransformedToken;
export type Tokens = import("../types/DesignToken.ts").DesignTokens;
export type PreprocessedTokens = import("../types/DesignToken.ts").PreprocessedTokens;
export type TransformedTokens = import("../types/DesignToken.ts").TransformedTokens;
export type Dictionary = import("../types/DesignToken.ts").Dictionary;
import { Register } from './Register.js';
